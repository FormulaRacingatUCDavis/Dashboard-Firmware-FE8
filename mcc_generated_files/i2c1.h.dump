<?xml version="1.0"?>
<dumps>
  <platform name="Native" char_bit="8" short_bit="16" int_bit="32" long_bit="64" long_long_bit="64" pointer_bit="64"/>
  <rawtokens>
    <file index="0" name="mcc_generated_files/i2c1.h"/>
    <tok fileIndex="0" linenr="2" column="1" str="/**x  I2C1 Generated Driver API Header Filexx  @Companyx    Microchip Technology Inc.xx  @File Namex    i2c1.hxx  @Summaryx    This is the generated header file for the I2C1 driver using PIC24 / dsPIC33 / PIC32MM MCUsxx  @Descriptionx    This header file provides APIs for driver for I2C1.x    Generation Information :x        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.170.0x        Device            :  dsPIC33EP128GM604xx    The generated drivers are tested against the following:x        Compiler          :  XC16 v1.61x        MPLAB x          :  MPLAB X v5.45x*/"/>
    <tok fileIndex="0" linenr="25" column="1" str="/*x    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use thisx    software and any derivatives exclusively with Microchip products.xx    THIS SOFTWARE IS SUPPLIED BY MICROCHIP &quot;AS IS&quot;. NO WARRANTIES, WHETHERx    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIEDx    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR Ax    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATIONx    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.xx    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,x    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KINDx    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HASx    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THEx    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS INx    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,x    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.xx    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESEx    TERMS.x*/"/>
    <tok fileIndex="0" linenr="47" column="1" str="#"/>
    <tok fileIndex="0" linenr="47" column="2" str="ifndef"/>
    <tok fileIndex="0" linenr="47" column="9" str="_I2C1_H"/>
    <tok fileIndex="0" linenr="48" column="1" str="#"/>
    <tok fileIndex="0" linenr="48" column="2" str="define"/>
    <tok fileIndex="0" linenr="48" column="9" str="_I2C1_H"/>
    <tok fileIndex="0" linenr="50" column="1" str="/**  Section: Included Files*/"/>
    <tok fileIndex="0" linenr="53" column="1" str="#"/>
    <tok fileIndex="0" linenr="53" column="2" str="include"/>
    <tok fileIndex="0" linenr="53" column="10" str="&lt;stdint.h&gt;"/>
    <tok fileIndex="0" linenr="54" column="1" str="#"/>
    <tok fileIndex="0" linenr="54" column="2" str="include"/>
    <tok fileIndex="0" linenr="54" column="10" str="&lt;stdbool.h&gt;"/>
    <tok fileIndex="0" linenr="55" column="1" str="#"/>
    <tok fileIndex="0" linenr="55" column="2" str="include"/>
    <tok fileIndex="0" linenr="55" column="10" str="&lt;stddef.h&gt;"/>
    <tok fileIndex="0" linenr="56" column="1" str="#"/>
    <tok fileIndex="0" linenr="56" column="2" str="include"/>
    <tok fileIndex="0" linenr="56" column="10" str="&lt;xc.h&gt;"/>
    <tok fileIndex="0" linenr="58" column="1" str="#"/>
    <tok fileIndex="0" linenr="58" column="2" str="ifdef"/>
    <tok fileIndex="0" linenr="58" column="8" str="__cplusplus"/>
    <tok fileIndex="0" linenr="58" column="21" str="// Provide C++ Compatibility"/>
    <tok fileIndex="0" linenr="60" column="5" str="extern"/>
    <tok fileIndex="0" linenr="60" column="12" str="&quot;C&quot;"/>
    <tok fileIndex="0" linenr="60" column="16" str="{"/>
    <tok fileIndex="0" linenr="62" column="1" str="#"/>
    <tok fileIndex="0" linenr="62" column="2" str="endif"/>
    <tok fileIndex="0" linenr="64" column="1" str="/** Section: Data Type Definitions*/"/>
    <tok fileIndex="0" linenr="68" column="1" str="/**x  I2C Driver Message Status Type Enumerationxx  @Summaryx    Defines the different message status when processingx    TRBs.xx  @Descriptionx    This type enumeration specifies the different types of statusx    that an i2c request will have. For every submission of an i2cx    transaction, the status of that transaction is available.x    Based on the status, new transactions can be requested to thex    driver or a recovery can be performed to resend the transaction.xx */"/>
    <tok fileIndex="0" linenr="84" column="1" str="typedef"/>
    <tok fileIndex="0" linenr="84" column="9" str="enum"/>
    <tok fileIndex="0" linenr="85" column="1" str="{"/>
    <tok fileIndex="0" linenr="86" column="5" str="I2C1_MESSAGE_FAIL"/>
    <tok fileIndex="0" linenr="86" column="22" str=","/>
    <tok fileIndex="0" linenr="87" column="5" str="I2C1_MESSAGE_PENDING"/>
    <tok fileIndex="0" linenr="87" column="25" str=","/>
    <tok fileIndex="0" linenr="88" column="5" str="I2C1_MESSAGE_COMPLETE"/>
    <tok fileIndex="0" linenr="88" column="26" str=","/>
    <tok fileIndex="0" linenr="89" column="5" str="I2C1_STUCK_START"/>
    <tok fileIndex="0" linenr="89" column="21" str=","/>
    <tok fileIndex="0" linenr="90" column="5" str="I2C1_MESSAGE_ADDRESS_NO_ACK"/>
    <tok fileIndex="0" linenr="90" column="32" str=","/>
    <tok fileIndex="0" linenr="91" column="5" str="I2C1_DATA_NO_ACK"/>
    <tok fileIndex="0" linenr="91" column="21" str=","/>
    <tok fileIndex="0" linenr="92" column="5" str="I2C1_LOST_STATE"/>
    <tok fileIndex="0" linenr="93" column="1" str="}"/>
    <tok fileIndex="0" linenr="93" column="3" str="I2C1_MESSAGE_STATUS"/>
    <tok fileIndex="0" linenr="93" column="22" str=";"/>
    <tok fileIndex="0" linenr="95" column="1" str="/**x  I2C Driver Transaction Request Block (TRB) type definition.xx  @Summaryx    This defines the Transaction Request Block (TRB) used by thex    i2c master in sending/receiving data to the i2c bus.xx  @Descriptionx    This data type is the i2c Transaction Request Block (TRB) thatx    the needs to be built and sent to the driver to handle each i2c requests.x    Using the TRB, simple to complex i2c transactions can be constructedx    and sent to the i2c bus. This data type is only used by the master mode.xx */"/>
    <tok fileIndex="0" linenr="109" column="1" str="typedef"/>
    <tok fileIndex="0" linenr="109" column="9" str="struct"/>
    <tok fileIndex="0" linenr="110" column="1" str="{"/>
    <tok fileIndex="0" linenr="111" column="5" str="uint16_t"/>
    <tok fileIndex="0" linenr="111" column="15" str="address"/>
    <tok fileIndex="0" linenr="111" column="22" str=";"/>
    <tok fileIndex="0" linenr="111" column="33" str="// Bits &lt;10:1&gt; are the 10 bit address."/>
    <tok fileIndex="0" linenr="112" column="33" str="// Bits &lt;7:1&gt; are the 7 bit address"/>
    <tok fileIndex="0" linenr="113" column="33" str="// Bit 0 is R/W (1 for read)"/>
    <tok fileIndex="0" linenr="114" column="5" str="uint8_t"/>
    <tok fileIndex="0" linenr="114" column="15" str="length"/>
    <tok fileIndex="0" linenr="114" column="21" str=";"/>
    <tok fileIndex="0" linenr="114" column="33" str="// the # of bytes in the buffer"/>
    <tok fileIndex="0" linenr="115" column="5" str="uint8_t"/>
    <tok fileIndex="0" linenr="115" column="15" str="*"/>
    <tok fileIndex="0" linenr="115" column="16" str="pbuffer"/>
    <tok fileIndex="0" linenr="115" column="23" str=";"/>
    <tok fileIndex="0" linenr="115" column="33" str="// a pointer to a buffer of length bytes"/>
    <tok fileIndex="0" linenr="116" column="1" str="}"/>
    <tok fileIndex="0" linenr="116" column="3" str="I2C1_TRANSACTION_REQUEST_BLOCK"/>
    <tok fileIndex="0" linenr="116" column="33" str=";"/>
    <tok fileIndex="0" linenr="118" column="1" str="/**x  Section: Interface Routinesx*/"/>
    <tok fileIndex="0" linenr="121" column="1" str="/**x  @Summaryx    Initializes the I2C instance : 1xx  @Descriptionx    This routine initializes the i2c1 driver instance for : 1x    index, making it ready for clients to open and use it.x    This routine must be called before any other I2C1 routine is called.x    This routine should only be called once during system initialization.xx  @Preconditionsx    None.xx  @Paramx    None.xx  @Returnsx    None.xx  @Examplex    &lt;code&gt;x        #define SLAVE_I2C_GENERIC_RETRY_MAX           100x        #define SLAVE_I2C_GENERIC_DEVICE_TIMEOUT      50   // define slave timeout x x        // initialize the modulex        I2C1_Initialize();xx        // write to an EEPROM Devicex        x        uint16_t        dataAddress;x        uint8_t         sourceData[16] = {  0xA0, 0xA1, 0xA2, 0xA3, x                                            0xA4, 0xA5, 0xA6, 0xA7, x                                            0xA8, 0xA9, 0xAA, 0xAB, x                                            0xAC, 0xAD, 0xAE, 0xAF }; x        uint8_t         *pData;x        uint16_t        nCount;xx        uint8_t         writeBuffer[3];x        uint8_t         *pD;x        uint16_t        counter, timeOut, slaveTimeOut;xx        I2C1_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;xx        dataAddress = 0x10;             // starting EEPROM address x        pD = sourceData;                // initialize the source of the datax        nCount = 16;                    // number of bytes to writexx        for (counter = 0; counter &lt; nCount; counter++)x        {xx            // build the write buffer firstx            // starting address of the EEPROM memoryx            writeBuffer[0] = (dataAddress &gt;&gt; 8);                // high addressx            writeBuffer[1] = (uint8_t)(dataAddress);            // low low addressxx            // data to be writtenx            writeBuffer[2] = *pD++;xx            // Now it is possible that the slave device will be slow.x            // As a work around on these slaves, the application canx            // retry sending the transactionx            timeOut = 0;x            slaveTimeOut = 0;x x            while(status != I2C1_MESSAGE_FAIL)x            {x                // write one byte to EEPROM (3 is the number of bytes to write)x                I2C1_MasterWrite(  writeBuffer,x                                        3,x                                        slaveDeviceAddress,x                                        &amp;status);xx                // wait for the message to be sent or status has changed.x                while(status == I2C1_MESSAGE_PENDING)x                {x                    // add some delay herexx                    // timeout checkingx                    // check for max retry and skip this bytex                    if (slaveTimeOut == SLAVE_I2C_GENERIC_DEVICE_TIMEOUT)x                        break;x                    elsex                        slaveTimeOut++;x                } x                if ((slaveTimeOut == SLAVE_I2C_GENERIC_DEVICE_TIMEOUT) || x                    (status == I2C1_MESSAGE_COMPLETE))x                    break;xx                // if status is  I2C1_MESSAGE_ADDRESS_NO_ACK,x                //               or I2C1_DATA_NO_ACK,x                // The device may be busy and needs more time for the lastx                // write so we can retry writing the data, this is why wex                // use a while loop herexx                // check for max retry and skip this bytex                if (timeOut == SLAVE_I2C_GENERIC_RETRY_MAX)x                    break;x                elsex                    timeOut++;x            }xx            if (status == I2C1_MESSAGE_FAIL)x            {x                break;x            }x            dataAddress++;xx        }xx    &lt;/code&gt;xx*/"/>
    <tok fileIndex="0" linenr="234" column="1" str="void"/>
    <tok fileIndex="0" linenr="234" column="6" str="I2C1_Initialize"/>
    <tok fileIndex="0" linenr="234" column="21" str="("/>
    <tok fileIndex="0" linenr="234" column="22" str="void"/>
    <tok fileIndex="0" linenr="234" column="26" str=")"/>
    <tok fileIndex="0" linenr="234" column="27" str=";"/>
    <tok fileIndex="0" linenr="237" column="1" str="/**x    @Summaryx        Handles one i2c master write transaction with thex        supplied parameters.xx    @Descriptionx        This function prepares a TRB, then inserts it on the i2c queue.x        Finally, it waits for the transaction to complete and returnsx        the result.xx    @Preconditionsx        Nonexx    @Paramx        address - The address of the i2c peripheral to be accessedxx    @Paramx        length - The length of the data block to be sentx    x    @Paramx        *pdata - A pointer to the block of data to be sentx    x    @Paramx        *pstatus - A pointer to the status variable that the i2c driverx            updates during the execution of the message.xx    @Returnsx        I2C1_MESSAGE_STATUSxx     @Examplex        &lt;code&gt;x            Refer to I2C1_Initialize() and x            I2C1_MasterRead() for an examplesxx        &lt;/code&gt;xx*/"/>
    <tok fileIndex="0" linenr="274" column="1" str="void"/>
    <tok fileIndex="0" linenr="274" column="6" str="I2C1_MasterWrite"/>
    <tok fileIndex="0" linenr="274" column="22" str="("/>
    <tok fileIndex="0" linenr="275" column="33" str="uint8_t"/>
    <tok fileIndex="0" linenr="275" column="41" str="*"/>
    <tok fileIndex="0" linenr="275" column="42" str="pdata"/>
    <tok fileIndex="0" linenr="275" column="47" str=","/>
    <tok fileIndex="0" linenr="276" column="33" str="uint8_t"/>
    <tok fileIndex="0" linenr="276" column="41" str="length"/>
    <tok fileIndex="0" linenr="276" column="47" str=","/>
    <tok fileIndex="0" linenr="277" column="33" str="uint16_t"/>
    <tok fileIndex="0" linenr="277" column="42" str="address"/>
    <tok fileIndex="0" linenr="277" column="49" str=","/>
    <tok fileIndex="0" linenr="278" column="33" str="I2C1_MESSAGE_STATUS"/>
    <tok fileIndex="0" linenr="278" column="53" str="*"/>
    <tok fileIndex="0" linenr="278" column="54" str="pstatus"/>
    <tok fileIndex="0" linenr="278" column="61" str=")"/>
    <tok fileIndex="0" linenr="278" column="62" str=";"/>
    <tok fileIndex="0" linenr="280" column="1" str="/**x    @Summaryx        Handles one i2c master read transaction with thex        supplied parameters.xx    @Descriptionx        This function prepares a TRB, then inserts it on the i2c queue.x        Finally, it waits for the transaction to complete and returnsx        the result.xx    @Preconditionsx        Nonexx    @Paramx        address - The address of the i2c peripheral to be accessedx    x    @Paramx        length - The length of the data block to be sentx    x    @Paramx        *pdata - A pointer to the memory location where received data willx                 be storedxx    @Paramx        *pstatus - A pointer to the status variable that the i2c driverx            updates during the execution of the message.xx    @Returnsx        I2C1_MESSAGE_STATUSxx    @Examplex        &lt;code&gt;x x            #define MCHP24AA512_RETRY_MAX       100  // define the retry countx            #define MCHP24AA512_ADDRESS         0x50 // slave device addressx            #define MCHP24AA512_DEVICE_TIMEOUT  50   // define slave timeout xxx            uint8_t MCHP24AA512_Read(x                                            uint16_t address,x                                            uint8_t *pData,x                                            uint16_t nCount)x            {x                I2C1_MESSAGE_STATUS status;x                uint8_t     writeBuffer[3];x                uint16_t    retryTimeOut, slaveTimeOut;x                uint16_t    counter;x                uint8_t     *pD;xx                pD = pData;xx                for (counter = 0; counter &lt; nCount; counter++)x                {xx                    // build the write buffer firstx                    // starting address of the EEPROM memoryx                    writeBuffer[0] = (address &gt;&gt; 8);                // high addressx                    writeBuffer[1] = (uint8_t)(address);            // low low addressxx                    // Now it is possible that the slave device will be slow.x                    // As a work around on these slaves, the application canx                    // retry sending the transactionx                    retryTimeOut = 0;x                    slaveTimeOut = 0;xx                    while(status != I2C1_MESSAGE_FAIL)x                    {x                        // write one byte to EEPROM (2 is the count of bytes to write)x                        I2C1_MasterWrite(    writeBuffer,x                                                2,x                                                MCHP24AA512_ADDRESS,x                                                &amp;status);xx                        // wait for the message to be sent or status has changed.x                        while(status == I2C1_MESSAGE_PENDING)x                        {x                            // add some delay herexx                            // timeout checkingx                            // check for max retry and skip this bytex                            if (slaveTimeOut == MCHP24AA512_DEVICE_TIMEOUT)x                                return (0);x                            elsex                                slaveTimeOut++;x                        }xx                        if (status == I2C1_MESSAGE_COMPLETE)x                            break;xx                        // if status is  I2C1_MESSAGE_ADDRESS_NO_ACK,x                        //               or I2C1_DATA_NO_ACK,x                        // The device may be busy and needs more time for the lastx                        // write so we can retry writing the data, this is why wex                        // use a while loop herexx                        // check for max retry and skip this bytex                        if (retryTimeOut == MCHP24AA512_RETRY_MAX)x                            break;x                        elsex                            retryTimeOut++;x                    }xx                    if (status == I2C1_MESSAGE_COMPLETE)x                    {xx                        // this portion will read the byte from the memory location.x                        retryTimeOut = 0;x                        slaveTimeOut = 0;xx                        while(status != I2C1_MESSAGE_FAIL)x                        {x                            // write one byte to EEPROM (2 is the count of bytes to write)x                            I2C1_MasterRead(     pD,x                                                    1,x                                                    MCHP24AA512_ADDRESS,x                                                    &amp;status);xx                            // wait for the message to be sent or status has changed.x                            while(status == I2C1_MESSAGE_PENDING)x                            {x                                // add some delay herexx                                // timeout checkingx                                // check for max retry and skip this bytex                                if (slaveTimeOut == MCHP24AA512_DEVICE_TIMEOUT)x                                    return (0);x                                elsex                                    slaveTimeOut++;x                            }xx                            if (status == I2C1_MESSAGE_COMPLETE)x                                break;xx                            // if status is  I2C1_MESSAGE_ADDRESS_NO_ACK,x                            //               or I2C1_DATA_NO_ACK,x                            // The device may be busy and needs more time for the lastx                            // write so we can retry writing the data, this is why wex                            // use a while loop herexx                            // check for max retry and skip this bytex                            if (retryTimeOut == MCHP24AA512_RETRY_MAX)x                                break;x                            elsex                                retryTimeOut++;x                        }x                    }xx                    // exit if the last transaction failedx                    if (status == I2C1_MESSAGE_FAIL)x                    {x                        return(0);x                        break;x                    }xx                    pD++;x                    address++;xx                }x                return(1);xx            }x   x  x        &lt;/code&gt;xx*/"/>
    <tok fileIndex="0" linenr="447" column="1" str="void"/>
    <tok fileIndex="0" linenr="447" column="6" str="I2C1_MasterRead"/>
    <tok fileIndex="0" linenr="447" column="21" str="("/>
    <tok fileIndex="0" linenr="448" column="33" str="uint8_t"/>
    <tok fileIndex="0" linenr="448" column="41" str="*"/>
    <tok fileIndex="0" linenr="448" column="42" str="pdata"/>
    <tok fileIndex="0" linenr="448" column="47" str=","/>
    <tok fileIndex="0" linenr="449" column="33" str="uint8_t"/>
    <tok fileIndex="0" linenr="449" column="41" str="length"/>
    <tok fileIndex="0" linenr="449" column="47" str=","/>
    <tok fileIndex="0" linenr="450" column="33" str="uint16_t"/>
    <tok fileIndex="0" linenr="450" column="42" str="address"/>
    <tok fileIndex="0" linenr="450" column="49" str=","/>
    <tok fileIndex="0" linenr="451" column="33" str="I2C1_MESSAGE_STATUS"/>
    <tok fileIndex="0" linenr="451" column="53" str="*"/>
    <tok fileIndex="0" linenr="451" column="54" str="pstatus"/>
    <tok fileIndex="0" linenr="451" column="61" str=")"/>
    <tok fileIndex="0" linenr="451" column="62" str=";"/>
    <tok fileIndex="0" linenr="453" column="1" str="/**x    @Summaryx        Inserts a list of i2c transaction requests into the i2cx        transaction queue.xx    @Descriptionx        The i2c processes lists of transaction requests.  Each transactionx        list is handled as a string of i2c restarts.  When the list ofx        transactions is complete, an i2c stop is produced, the flag is setx        with the correct condition code and the next list is processedx        from the queue.xx        This function inserts lists of requests prepared by the userx        application into the queue along with a pointer to the completionx        flag.xx        The transaction is inserted into the list only if there is spacex        in the list. If there is no space, the function exits with thex        flag set to I2C1_MESSAGE_FAIL.xx    @Preconditionsx        Nonexx    @Paramx        count - The numer of transaction requests in the trb_list.xx    @Paramx        *ptrb_list - A pointer to an array of transaction requests (TRB).x            See I2C1_TRANSACTION_REQUEST_BLOCK definition for details.x    x    @Paramx        *pflag - A pointer to a completion flag.xx    @Returnsx        Nonexx    @Examplex        &lt;code&gt;xx  x            uint8_t EMULATED_EEPROM_Read(x                                           uint16_t slaveDeviceAddress,x                                           uint16_t dataAddress,x                                           uint8_t *pData,x                                           uint16_t nCount)x            {x                I2C1_MESSAGE_STATUS status;x                I2C1_TRANSACTION_REQUEST_BLOCK readTRB[2];x                uint8_t     writeBuffer[3];x                uint16_t    timeOut, slaveTimeOut;xx                // this initial value is importantx                status = I2C1_MESSAGE_PENDING;xx                // build the write buffer firstx                // starting address of the EEPROM memoryx                writeBuffer[0] = (dataAddress &gt;&gt; 8);                        // high addressx                writeBuffer[1] = (uint8_t)(dataAddress);                    // low low addressxx                // we need to create the TRBs for a random read sequence to the EEPROMx                // Build TRB for sending addressx                I2C1_MasterWriteTRBBuild(    &amp;readTRB[0],x                                                writeBuffer,x                                                2,x                                                slaveDeviceAddress);x                // Build TRB for receiving datax                I2C1_MasterReadTRBBuild(     &amp;readTRB[1],x                                                pData,x                                                nCount,x                                                slaveDeviceAddress);xx                timeOut = 0;x                slaveTimeOut = 0;xx                while(status != I2C1_MESSAGE_FAIL)x                {x                    // now send the transactionsx                    I2C1_MasterTRBInsert(2, readTRB, &amp;status);xx                    // wait for the message to be sent or status has changed.x                    while(status == I2C1_MESSAGE_PENDING)x                    {x                        // add some delay herexx                        // timeout checkingx                        // check for max retry and skip this bytex                        if (slaveTimeOut == SLAVE_I2C_GENERIC_SLAVE_TIMEOUT)x                            return (0);x                        elsex                            slaveTimeOut++;x                    }xx                    if (status == I2C1_MESSAGE_COMPLETE)x                        break;xx                    // if status is  I2C1_MESSAGE_ADDRESS_NO_ACK,x                    //               or I2C1_DATA_NO_ACK,x                    // The device may be busy and needs more time for the lastx                    // write so we can retry writing the data, this is why wex                    // use a while loop herexx                    // check for max retry and skip this bytex                    if (timeOut == SLAVE_I2C_GENERIC_RETRY_MAX)x                        return (0);x                    elsex                        timeOut++;xx                }x                return (1);xx            }   x  x        &lt;/code&gt;xx*/"/>
    <tok fileIndex="0" linenr="569" column="1" str="void"/>
    <tok fileIndex="0" linenr="569" column="6" str="I2C1_MasterTRBInsert"/>
    <tok fileIndex="0" linenr="569" column="26" str="("/>
    <tok fileIndex="0" linenr="570" column="33" str="uint8_t"/>
    <tok fileIndex="0" linenr="570" column="41" str="count"/>
    <tok fileIndex="0" linenr="570" column="46" str=","/>
    <tok fileIndex="0" linenr="571" column="33" str="I2C1_TRANSACTION_REQUEST_BLOCK"/>
    <tok fileIndex="0" linenr="571" column="64" str="*"/>
    <tok fileIndex="0" linenr="571" column="65" str="ptrb_list"/>
    <tok fileIndex="0" linenr="571" column="74" str=","/>
    <tok fileIndex="0" linenr="572" column="33" str="I2C1_MESSAGE_STATUS"/>
    <tok fileIndex="0" linenr="572" column="53" str="*"/>
    <tok fileIndex="0" linenr="572" column="54" str="pflag"/>
    <tok fileIndex="0" linenr="572" column="59" str=")"/>
    <tok fileIndex="0" linenr="572" column="60" str=";"/>
    <tok fileIndex="0" linenr="574" column="1" str="/**x    @Summaryx        This function populates a trb supplied by the calling functionx        with the parameters supplied by the calling function.xx    @Descriptionx        All i2c requests are in the form of TRB's. This helper functionx        takes standard parameters and correctly formats the TRB. The R/Wx        bit is set to ensure that the resulting TRB describes an i2c readx        operation.xx        This function does not send the transaction. To send the transaction,x        the TRB insert function (I2C1_MasterTRBInsert()) must be called.xx    @Preconditionsx        Nonexx    @Paramx        *ptrb - A pointer to a caller supplied TRB.xx    @Paramx        *pdata - A pointer to the block of data to be receivedxx    @Paramx        length - The length of the data block to be receivedxx    @Paramx        address - The address of the i2c peripheral to be accessedxx    @Returnsx        Nonexx    @Examplex        &lt;code&gt;x            Refer to I2C1_MasterTRBInsert() for an examplexx        &lt;/code&gt;xx*/"/>
    <tok fileIndex="0" linenr="613" column="1" str="void"/>
    <tok fileIndex="0" linenr="613" column="6" str="I2C1_MasterReadTRBBuild"/>
    <tok fileIndex="0" linenr="613" column="29" str="("/>
    <tok fileIndex="0" linenr="614" column="33" str="I2C1_TRANSACTION_REQUEST_BLOCK"/>
    <tok fileIndex="0" linenr="614" column="64" str="*"/>
    <tok fileIndex="0" linenr="614" column="65" str="ptrb"/>
    <tok fileIndex="0" linenr="614" column="69" str=","/>
    <tok fileIndex="0" linenr="615" column="33" str="uint8_t"/>
    <tok fileIndex="0" linenr="615" column="41" str="*"/>
    <tok fileIndex="0" linenr="615" column="42" str="pdata"/>
    <tok fileIndex="0" linenr="615" column="47" str=","/>
    <tok fileIndex="0" linenr="616" column="33" str="uint8_t"/>
    <tok fileIndex="0" linenr="616" column="41" str="length"/>
    <tok fileIndex="0" linenr="616" column="47" str=","/>
    <tok fileIndex="0" linenr="617" column="33" str="uint16_t"/>
    <tok fileIndex="0" linenr="617" column="42" str="address"/>
    <tok fileIndex="0" linenr="617" column="49" str=")"/>
    <tok fileIndex="0" linenr="617" column="50" str=";"/>
    <tok fileIndex="0" linenr="619" column="1" str="/**x    @Summaryx        This function populates a trb supplied by the calling functionx        with the parameters supplied by the calling function.xx    @Descriptionx        All i2c requests are in the form of TRB's.  This helper functionx        takes standard parameters and correctly formats the TRB. The R/Wx        bit is cleared to ensure that the resulting TRB describes an i2cx        write operation.xx        This function does not send the transaction. To send the transaction,x        the TRB insert function (I2C1_MasterTRBInsert()) must be called.xx    @Preconditionsx        Nonexx    @Paramx        *ptrb - A pointer to a caller supplied TRB.xx    @Paramx        *pdata - A pointer to the block of data to be sentxx    @Paramx        length - The length of the data block to be sentxx    @Paramx        address - The address of the i2c peripheral to be accessedxx    @Returnsx        Nonexx    @Examplex        &lt;code&gt;x            Refer to I2C1_MasterTRBInsert() for an examplexx        &lt;/code&gt;xx*/"/>
    <tok fileIndex="0" linenr="658" column="1" str="void"/>
    <tok fileIndex="0" linenr="658" column="6" str="I2C1_MasterWriteTRBBuild"/>
    <tok fileIndex="0" linenr="658" column="30" str="("/>
    <tok fileIndex="0" linenr="659" column="33" str="I2C1_TRANSACTION_REQUEST_BLOCK"/>
    <tok fileIndex="0" linenr="659" column="64" str="*"/>
    <tok fileIndex="0" linenr="659" column="65" str="ptrb"/>
    <tok fileIndex="0" linenr="659" column="69" str=","/>
    <tok fileIndex="0" linenr="660" column="33" str="uint8_t"/>
    <tok fileIndex="0" linenr="660" column="41" str="*"/>
    <tok fileIndex="0" linenr="660" column="42" str="pdata"/>
    <tok fileIndex="0" linenr="660" column="47" str=","/>
    <tok fileIndex="0" linenr="661" column="33" str="uint8_t"/>
    <tok fileIndex="0" linenr="661" column="41" str="length"/>
    <tok fileIndex="0" linenr="661" column="47" str=","/>
    <tok fileIndex="0" linenr="662" column="33" str="uint16_t"/>
    <tok fileIndex="0" linenr="662" column="42" str="address"/>
    <tok fileIndex="0" linenr="662" column="49" str=")"/>
    <tok fileIndex="0" linenr="662" column="50" str=";"/>
    <tok fileIndex="0" linenr="664" column="1" str="/**x    @Summaryx        This function returns the empty status of the Masterx        queue.xx    @Descriptionx        This function returns the empty status of the Masterx        queue. Use this function to check if the queue is empty.x        This can verify if the Master is currently idle.xx    @Preconditionsx        Nonexx    @Paramx        Nonexx    @Returnsx        True if the queue is empty and false if the queue is not empty.xx    @Examplex        &lt;code&gt;x            #define MCHP24AA512_ADDRESS    0x50 // slave device addressxx            // check until queue is emptyx            while(I2C1_MasterQueueIsEmpty() == false);x            x            // now send more data (assume readBuffer is initialized)x            I2C1_MasterRead(   readBuffer,x                                    3,x                                    MCHP24AA512_ADDRESS,x                                    &amp;status);   x  x        &lt;/code&gt;xx*/"/>
    <tok fileIndex="0" linenr="700" column="1" str="bool"/>
    <tok fileIndex="0" linenr="700" column="6" str="I2C1_MasterQueueIsEmpty"/>
    <tok fileIndex="0" linenr="700" column="29" str="("/>
    <tok fileIndex="0" linenr="700" column="30" str="void"/>
    <tok fileIndex="0" linenr="700" column="34" str=")"/>
    <tok fileIndex="0" linenr="700" column="35" str=";"/>
    <tok fileIndex="0" linenr="702" column="1" str="/**x    @Summaryx        This function returns the full status of the Masterx        queue.xx    @Descriptionx        This function returns the full status of the Masterx        queue. Use this function to check if the queue is full.x        This can verify if the Master will not be able to acceptx        addition transactions.xx    @Preconditionsx        Nonexx    @Paramx        Nonexx    @Returnsx        True if the queue is full and false if the queue is not full.xx    @Examplex        &lt;code&gt;x            #define MCHP24AA512_ADDRESS    0x50 // slave device addressx x            // check until queue has spacex            while(I2C1_MasterQueueIsFull() == true);x            x            // now send more data (assume readBuffer is initialized)x            I2C1_MasterRead(   readBuffer,x                                    3,x                                    MCHP24AA512_ADDRESS,x                                    &amp;status); x        &lt;/code&gt;xx*/"/>
    <tok fileIndex="0" linenr="738" column="1" str="bool"/>
    <tok fileIndex="0" linenr="738" column="6" str="I2C1_MasterQueueIsFull"/>
    <tok fileIndex="0" linenr="738" column="28" str="("/>
    <tok fileIndex="0" linenr="738" column="29" str="void"/>
    <tok fileIndex="0" linenr="738" column="33" str=")"/>
    <tok fileIndex="0" linenr="738" column="34" str=";"/>
    <tok fileIndex="0" linenr="740" column="1" str="#"/>
    <tok fileIndex="0" linenr="740" column="2" str="ifdef"/>
    <tok fileIndex="0" linenr="740" column="8" str="__cplusplus"/>
    <tok fileIndex="0" linenr="740" column="21" str="// Provide C++ Compatibility"/>
    <tok fileIndex="0" linenr="742" column="5" str="}"/>
    <tok fileIndex="0" linenr="744" column="1" str="#"/>
    <tok fileIndex="0" linenr="744" column="2" str="endif"/>
    <tok fileIndex="0" linenr="746" column="1" str="#"/>
    <tok fileIndex="0" linenr="746" column="2" str="endif"/>
    <tok fileIndex="0" linenr="746" column="8" str="//_I2C1_H"/>
    <tok fileIndex="0" linenr="748" column="1" str="/** End of File*/"/>
  </rawtokens>
  <suppressions>
  </suppressions>
<dump cfg="">
  <standards>
    <c version="c11"/>
    <cpp version="c++20"/>
  </standards>
  <directivelist>
    <directive file="mcc_generated_files/i2c1.h" linenr="47" str="#ifndef _I2C1_H"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="48" str="#define _I2C1_H"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="53" str="#include &lt;stdint.h&gt;"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="54" str="#include &lt;stdbool.h&gt;"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="55" str="#include &lt;stddef.h&gt;"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="56" str="#include &lt;xc.h&gt;"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="58" str="#ifdef __cplusplus"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="62" str="#endif"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="740" str="#ifdef __cplusplus"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="744" str="#endif"/>
    <directive file="mcc_generated_files/i2c1.h" linenr="746" str="#endif"/>
  </directivelist>
  <tokenlist>
    <token id="0x7fd8ca69c840" file="mcc_generated_files/i2c1.h" linenr="84" column="9" str="enum" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a4940" file="mcc_generated_files/i2c1.h" linenr="84" column="0" str="I2C1_MESSAGE_STATUS" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69c9e0" file="mcc_generated_files/i2c1.h" linenr="85" column="1" str="{" scope="0x7fd8ca69eed0" link="0x7fd8ca69e070"/>
    <token id="0x7fd8ca69d590" file="mcc_generated_files/i2c1.h" linenr="86" column="5" str="I2C1_MESSAGE_FAIL" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69d660" file="mcc_generated_files/i2c1.h" linenr="86" column="22" str="," scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69d730" file="mcc_generated_files/i2c1.h" linenr="87" column="5" str="I2C1_MESSAGE_PENDING" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69d800" file="mcc_generated_files/i2c1.h" linenr="87" column="25" str="," scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69d8d0" file="mcc_generated_files/i2c1.h" linenr="88" column="5" str="I2C1_MESSAGE_COMPLETE" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69d9a0" file="mcc_generated_files/i2c1.h" linenr="88" column="26" str="," scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69da70" file="mcc_generated_files/i2c1.h" linenr="89" column="5" str="I2C1_STUCK_START" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69db40" file="mcc_generated_files/i2c1.h" linenr="89" column="21" str="," scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69dc30" file="mcc_generated_files/i2c1.h" linenr="90" column="5" str="I2C1_MESSAGE_ADDRESS_NO_ACK" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69dd30" file="mcc_generated_files/i2c1.h" linenr="90" column="32" str="," scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69de00" file="mcc_generated_files/i2c1.h" linenr="91" column="5" str="I2C1_DATA_NO_ACK" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69ded0" file="mcc_generated_files/i2c1.h" linenr="91" column="21" str="," scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69dfa0" file="mcc_generated_files/i2c1.h" linenr="92" column="5" str="I2C1_LOST_STATE" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69e070" file="mcc_generated_files/i2c1.h" linenr="93" column="1" str="}" scope="0x7fd8ca69eed0" link="0x7fd8ca69c9e0"/>
    <token id="0x7fd8ca6a4a10" file="mcc_generated_files/i2c1.h" linenr="93" column="0" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca6a4ae0" file="mcc_generated_files/i2c1.h" linenr="109" column="9" str="struct" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69e2e0" file="mcc_generated_files/i2c1.h" linenr="109" column="0" str="I2C1_TRANSACTION_REQUEST_BLOCK" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69e480" file="mcc_generated_files/i2c1.h" linenr="110" column="1" str="{" scope="0x7fd8ca69eed0" link="0x7fd8ca69ed70"/>
    <token id="0x7fd8ca69e550" file="mcc_generated_files/i2c1.h" linenr="111" column="5" str="uint16_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69e620" file="mcc_generated_files/i2c1.h" linenr="111" column="15" str="address" scope="0x7fd8ca69eed0" type="name" varId="1"/>
    <token id="0x7fd8ca69e6f0" file="mcc_generated_files/i2c1.h" linenr="111" column="22" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69e7c0" file="mcc_generated_files/i2c1.h" linenr="114" column="5" str="uint8_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69e890" file="mcc_generated_files/i2c1.h" linenr="114" column="15" str="length" scope="0x7fd8ca69eed0" type="name" varId="2"/>
    <token id="0x7fd8ca69e960" file="mcc_generated_files/i2c1.h" linenr="114" column="21" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69ea30" file="mcc_generated_files/i2c1.h" linenr="115" column="5" str="uint8_t" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca69eb00"/>
    <token id="0x7fd8ca69eb00" file="mcc_generated_files/i2c1.h" linenr="115" column="15" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astOperand1="0x7fd8ca69ea30" astOperand2="0x7fd8ca69ebd0"/>
    <token id="0x7fd8ca69ebd0" file="mcc_generated_files/i2c1.h" linenr="115" column="16" str="pbuffer" scope="0x7fd8ca69eed0" type="name" varId="3" astParent="0x7fd8ca69eb00"/>
    <token id="0x7fd8ca69eca0" file="mcc_generated_files/i2c1.h" linenr="115" column="23" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69ed70" file="mcc_generated_files/i2c1.h" linenr="116" column="1" str="}" scope="0x7fd8ca69eed0" link="0x7fd8ca69e480"/>
    <token id="0x7fd8ca69e170" file="mcc_generated_files/i2c1.h" linenr="116" column="0" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69f010" file="mcc_generated_files/i2c1.h" linenr="234" column="1" str="void" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69f0e0" file="mcc_generated_files/i2c1.h" linenr="234" column="6" str="I2C1_Initialize" scope="0x7fd8ca69eed0" type="name" function="0x7fd8ca69f290" astParent="0x7fd8ca69f1b0"/>
    <token id="0x7fd8ca69f1b0" file="mcc_generated_files/i2c1.h" linenr="234" column="21" str="(" scope="0x7fd8ca69eed0" link="0x7fd8ca69f350" astOperand1="0x7fd8ca69f0e0" valueType-type="void"/>
    <token id="0x7fd8ca69f350" file="mcc_generated_files/i2c1.h" linenr="234" column="26" str=")" scope="0x7fd8ca69eed0" link="0x7fd8ca69f1b0"/>
    <token id="0x7fd8ca69f420" file="mcc_generated_files/i2c1.h" linenr="234" column="27" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca69f4f0" file="mcc_generated_files/i2c1.h" linenr="274" column="1" str="void" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69f5c0" file="mcc_generated_files/i2c1.h" linenr="274" column="6" str="I2C1_MasterWrite" scope="0x7fd8ca69eed0" type="name" function="0x7fd8ca6a4b40" astParent="0x7fd8ca69f690"/>
    <token id="0x7fd8ca69f690" file="mcc_generated_files/i2c1.h" linenr="274" column="22" str="(" scope="0x7fd8ca69eed0" link="0x7fd8ca6a01f0" astOperand1="0x7fd8ca69f5c0" astOperand2="0x7fd8ca69feb0" valueType-type="void"/>
    <token id="0x7fd8ca69f760" file="mcc_generated_files/i2c1.h" linenr="275" column="33" str="uint8_t" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca69f830"/>
    <token id="0x7fd8ca69f830" file="mcc_generated_files/i2c1.h" linenr="275" column="41" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca69f9d0" astOperand1="0x7fd8ca69f760" astOperand2="0x7fd8ca69f900"/>
    <token id="0x7fd8ca69f900" file="mcc_generated_files/i2c1.h" linenr="275" column="42" str="pdata" scope="0x7fd8ca69eed0" type="name" varId="4" variable="0x7fd8ca6a5320" astParent="0x7fd8ca69f830" valueType-type="char" valueType-sign="unsigned" valueType-pointer="1"/>
    <token id="0x7fd8ca69f9d0" file="mcc_generated_files/i2c1.h" linenr="275" column="47" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca69fc40" astOperand1="0x7fd8ca69f830" astOperand2="0x7fd8ca69fb70"/>
    <token id="0x7fd8ca69faa0" file="mcc_generated_files/i2c1.h" linenr="276" column="33" str="uint8_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69fb70" file="mcc_generated_files/i2c1.h" linenr="276" column="41" str="length" scope="0x7fd8ca69eed0" type="name" varId="5" variable="0x7fd8ca6a53f0" astParent="0x7fd8ca69f9d0" valueType-type="char" valueType-sign="unsigned"/>
    <token id="0x7fd8ca69fc40" file="mcc_generated_files/i2c1.h" linenr="276" column="47" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca69feb0" astOperand1="0x7fd8ca69f9d0" astOperand2="0x7fd8ca69fde0"/>
    <token id="0x7fd8ca69fd10" file="mcc_generated_files/i2c1.h" linenr="277" column="33" str="uint16_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69fde0" file="mcc_generated_files/i2c1.h" linenr="277" column="42" str="address" scope="0x7fd8ca69eed0" type="name" varId="6" variable="0x7fd8ca6a54c0" astParent="0x7fd8ca69fc40" valueType-type="short" valueType-sign="unsigned"/>
    <token id="0x7fd8ca69feb0" file="mcc_generated_files/i2c1.h" linenr="277" column="49" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca69f690" astOperand1="0x7fd8ca69fc40" astOperand2="0x7fd8ca6a0050"/>
    <token id="0x7fd8ca69ff80" file="mcc_generated_files/i2c1.h" linenr="278" column="33" str="I2C1_MESSAGE_STATUS" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca6a0050"/>
    <token id="0x7fd8ca6a0050" file="mcc_generated_files/i2c1.h" linenr="278" column="53" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca69feb0" astOperand1="0x7fd8ca69ff80" astOperand2="0x7fd8ca6a0120"/>
    <token id="0x7fd8ca6a0120" file="mcc_generated_files/i2c1.h" linenr="278" column="54" str="pstatus" scope="0x7fd8ca69eed0" type="name" varId="7" variable="0x7fd8ca6a5590" astParent="0x7fd8ca6a0050"/>
    <token id="0x7fd8ca6a01f0" file="mcc_generated_files/i2c1.h" linenr="278" column="61" str=")" scope="0x7fd8ca69eed0" link="0x7fd8ca69f690"/>
    <token id="0x7fd8ca6a02c0" file="mcc_generated_files/i2c1.h" linenr="278" column="62" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca6a0390" file="mcc_generated_files/i2c1.h" linenr="447" column="1" str="void" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a0460" file="mcc_generated_files/i2c1.h" linenr="447" column="6" str="I2C1_MasterRead" scope="0x7fd8ca69eed0" type="name" function="0x7fd8ca6a4be0" astParent="0x7fd8ca6a0530"/>
    <token id="0x7fd8ca6a0530" file="mcc_generated_files/i2c1.h" linenr="447" column="21" str="(" scope="0x7fd8ca69eed0" link="0x7fd8ca6a1090" astOperand1="0x7fd8ca6a0460" astOperand2="0x7fd8ca6a0d50" valueType-type="void"/>
    <token id="0x7fd8ca6a0600" file="mcc_generated_files/i2c1.h" linenr="448" column="33" str="uint8_t" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca6a06d0"/>
    <token id="0x7fd8ca6a06d0" file="mcc_generated_files/i2c1.h" linenr="448" column="41" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca6a0870" astOperand1="0x7fd8ca6a0600" astOperand2="0x7fd8ca6a07a0"/>
    <token id="0x7fd8ca6a07a0" file="mcc_generated_files/i2c1.h" linenr="448" column="42" str="pdata" scope="0x7fd8ca69eed0" type="name" varId="8" variable="0x7fd8ca6a5660" astParent="0x7fd8ca6a06d0" valueType-type="char" valueType-sign="unsigned" valueType-pointer="1"/>
    <token id="0x7fd8ca6a0870" file="mcc_generated_files/i2c1.h" linenr="448" column="47" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a0ae0" astOperand1="0x7fd8ca6a06d0" astOperand2="0x7fd8ca6a0a10"/>
    <token id="0x7fd8ca6a0940" file="mcc_generated_files/i2c1.h" linenr="449" column="33" str="uint8_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a0a10" file="mcc_generated_files/i2c1.h" linenr="449" column="41" str="length" scope="0x7fd8ca69eed0" type="name" varId="9" variable="0x7fd8ca6a5730" astParent="0x7fd8ca6a0870" valueType-type="char" valueType-sign="unsigned"/>
    <token id="0x7fd8ca6a0ae0" file="mcc_generated_files/i2c1.h" linenr="449" column="47" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a0d50" astOperand1="0x7fd8ca6a0870" astOperand2="0x7fd8ca6a0c80"/>
    <token id="0x7fd8ca6a0bb0" file="mcc_generated_files/i2c1.h" linenr="450" column="33" str="uint16_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a0c80" file="mcc_generated_files/i2c1.h" linenr="450" column="42" str="address" scope="0x7fd8ca69eed0" type="name" varId="10" variable="0x7fd8ca6a5800" astParent="0x7fd8ca6a0ae0" valueType-type="short" valueType-sign="unsigned"/>
    <token id="0x7fd8ca6a0d50" file="mcc_generated_files/i2c1.h" linenr="450" column="49" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a0530" astOperand1="0x7fd8ca6a0ae0" astOperand2="0x7fd8ca6a0ef0"/>
    <token id="0x7fd8ca6a0e20" file="mcc_generated_files/i2c1.h" linenr="451" column="33" str="I2C1_MESSAGE_STATUS" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca6a0ef0"/>
    <token id="0x7fd8ca6a0ef0" file="mcc_generated_files/i2c1.h" linenr="451" column="53" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca6a0d50" astOperand1="0x7fd8ca6a0e20" astOperand2="0x7fd8ca6a0fc0"/>
    <token id="0x7fd8ca6a0fc0" file="mcc_generated_files/i2c1.h" linenr="451" column="54" str="pstatus" scope="0x7fd8ca69eed0" type="name" varId="11" variable="0x7fd8ca6a58d0" astParent="0x7fd8ca6a0ef0"/>
    <token id="0x7fd8ca6a1090" file="mcc_generated_files/i2c1.h" linenr="451" column="61" str=")" scope="0x7fd8ca69eed0" link="0x7fd8ca6a0530"/>
    <token id="0x7fd8ca6a1160" file="mcc_generated_files/i2c1.h" linenr="451" column="62" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca6a1230" file="mcc_generated_files/i2c1.h" linenr="569" column="1" str="void" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a1300" file="mcc_generated_files/i2c1.h" linenr="569" column="6" str="I2C1_MasterTRBInsert" scope="0x7fd8ca69eed0" type="name" function="0x7fd8ca6a4f40" astParent="0x7fd8ca6a13d0"/>
    <token id="0x7fd8ca6a13d0" file="mcc_generated_files/i2c1.h" linenr="569" column="26" str="(" scope="0x7fd8ca69eed0" link="0x7fd8ca6a1cf0" astOperand1="0x7fd8ca6a1300" astOperand2="0x7fd8ca6a19b0" valueType-type="void"/>
    <token id="0x7fd8ca6a14a0" file="mcc_generated_files/i2c1.h" linenr="570" column="33" str="uint8_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a1570" file="mcc_generated_files/i2c1.h" linenr="570" column="41" str="count" scope="0x7fd8ca69eed0" type="name" varId="12" variable="0x7fd8ca6a59a0" astParent="0x7fd8ca6a1640" valueType-type="char" valueType-sign="unsigned"/>
    <token id="0x7fd8ca6a1640" file="mcc_generated_files/i2c1.h" linenr="570" column="46" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a19b0" astOperand1="0x7fd8ca6a1570" astOperand2="0x7fd8ca6a1810"/>
    <token id="0x7fd8ca6a1710" file="mcc_generated_files/i2c1.h" linenr="571" column="33" str="struct" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca69e330" file="mcc_generated_files/i2c1.h" linenr="571" column="0" str="I2C1_TRANSACTION_REQUEST_BLOCK" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca6a1810"/>
    <token id="0x7fd8ca6a1810" file="mcc_generated_files/i2c1.h" linenr="571" column="64" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca6a1640" astOperand1="0x7fd8ca69e330" astOperand2="0x7fd8ca6a18e0"/>
    <token id="0x7fd8ca6a18e0" file="mcc_generated_files/i2c1.h" linenr="571" column="65" str="ptrb_list" scope="0x7fd8ca69eed0" type="name" varId="13" variable="0x7fd8ca6a5a70" astParent="0x7fd8ca6a1810" valueType-type="record" valueType-pointer="1"/>
    <token id="0x7fd8ca6a19b0" file="mcc_generated_files/i2c1.h" linenr="571" column="74" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a13d0" astOperand1="0x7fd8ca6a1640" astOperand2="0x7fd8ca6a1b50"/>
    <token id="0x7fd8ca6a1a80" file="mcc_generated_files/i2c1.h" linenr="572" column="33" str="I2C1_MESSAGE_STATUS" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca6a1b50"/>
    <token id="0x7fd8ca6a1b50" file="mcc_generated_files/i2c1.h" linenr="572" column="53" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca6a19b0" astOperand1="0x7fd8ca6a1a80" astOperand2="0x7fd8ca6a1c20"/>
    <token id="0x7fd8ca6a1c20" file="mcc_generated_files/i2c1.h" linenr="572" column="54" str="pflag" scope="0x7fd8ca69eed0" type="name" varId="14" variable="0x7fd8ca6a5b40" astParent="0x7fd8ca6a1b50"/>
    <token id="0x7fd8ca6a1cf0" file="mcc_generated_files/i2c1.h" linenr="572" column="59" str=")" scope="0x7fd8ca69eed0" link="0x7fd8ca6a13d0"/>
    <token id="0x7fd8ca6a1dc0" file="mcc_generated_files/i2c1.h" linenr="572" column="60" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca6a1e90" file="mcc_generated_files/i2c1.h" linenr="613" column="1" str="void" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a1f60" file="mcc_generated_files/i2c1.h" linenr="613" column="6" str="I2C1_MasterReadTRBBuild" scope="0x7fd8ca69eed0" type="name" function="0x7fd8ca6a4fe0" astParent="0x7fd8ca6a2060"/>
    <token id="0x7fd8ca6a2060" file="mcc_generated_files/i2c1.h" linenr="613" column="29" str="(" scope="0x7fd8ca69eed0" link="0x7fd8ca6a2bf0" astOperand1="0x7fd8ca6a1f60" astOperand2="0x7fd8ca6a2980" valueType-type="void"/>
    <token id="0x7fd8ca6a2130" file="mcc_generated_files/i2c1.h" linenr="614" column="33" str="struct" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a4d30" file="mcc_generated_files/i2c1.h" linenr="614" column="0" str="I2C1_TRANSACTION_REQUEST_BLOCK" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca6a2230"/>
    <token id="0x7fd8ca6a2230" file="mcc_generated_files/i2c1.h" linenr="614" column="64" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca6a23d0" astOperand1="0x7fd8ca6a4d30" astOperand2="0x7fd8ca6a2300"/>
    <token id="0x7fd8ca6a2300" file="mcc_generated_files/i2c1.h" linenr="614" column="65" str="ptrb" scope="0x7fd8ca69eed0" type="name" varId="15" variable="0x7fd8ca6a5c10" astParent="0x7fd8ca6a2230" valueType-type="record" valueType-pointer="1"/>
    <token id="0x7fd8ca6a23d0" file="mcc_generated_files/i2c1.h" linenr="614" column="69" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a2710" astOperand1="0x7fd8ca6a2230" astOperand2="0x7fd8ca6a2570"/>
    <token id="0x7fd8ca6a24a0" file="mcc_generated_files/i2c1.h" linenr="615" column="33" str="uint8_t" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca6a2570"/>
    <token id="0x7fd8ca6a2570" file="mcc_generated_files/i2c1.h" linenr="615" column="41" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca6a23d0" astOperand1="0x7fd8ca6a24a0" astOperand2="0x7fd8ca6a2640"/>
    <token id="0x7fd8ca6a2640" file="mcc_generated_files/i2c1.h" linenr="615" column="42" str="pdata" scope="0x7fd8ca69eed0" type="name" varId="16" variable="0x7fd8ca6a5ce0" astParent="0x7fd8ca6a2570" valueType-type="char" valueType-sign="unsigned" valueType-pointer="1"/>
    <token id="0x7fd8ca6a2710" file="mcc_generated_files/i2c1.h" linenr="615" column="47" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a2980" astOperand1="0x7fd8ca6a23d0" astOperand2="0x7fd8ca6a28b0"/>
    <token id="0x7fd8ca6a27e0" file="mcc_generated_files/i2c1.h" linenr="616" column="33" str="uint8_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a28b0" file="mcc_generated_files/i2c1.h" linenr="616" column="41" str="length" scope="0x7fd8ca69eed0" type="name" varId="17" variable="0x7fd8ca6a5db0" astParent="0x7fd8ca6a2710" valueType-type="char" valueType-sign="unsigned"/>
    <token id="0x7fd8ca6a2980" file="mcc_generated_files/i2c1.h" linenr="616" column="47" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a2060" astOperand1="0x7fd8ca6a2710" astOperand2="0x7fd8ca6a2b20"/>
    <token id="0x7fd8ca6a2a50" file="mcc_generated_files/i2c1.h" linenr="617" column="33" str="uint16_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a2b20" file="mcc_generated_files/i2c1.h" linenr="617" column="42" str="address" scope="0x7fd8ca69eed0" type="name" varId="18" variable="0x7fd8ca6a5e80" astParent="0x7fd8ca6a2980" valueType-type="short" valueType-sign="unsigned"/>
    <token id="0x7fd8ca6a2bf0" file="mcc_generated_files/i2c1.h" linenr="617" column="49" str=")" scope="0x7fd8ca69eed0" link="0x7fd8ca6a2060"/>
    <token id="0x7fd8ca6a2cc0" file="mcc_generated_files/i2c1.h" linenr="617" column="50" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca6a2d90" file="mcc_generated_files/i2c1.h" linenr="658" column="1" str="void" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a2e60" file="mcc_generated_files/i2c1.h" linenr="658" column="6" str="I2C1_MasterWriteTRBBuild" scope="0x7fd8ca69eed0" type="name" function="0x7fd8ca6a5080" astParent="0x7fd8ca6a2f60"/>
    <token id="0x7fd8ca6a2f60" file="mcc_generated_files/i2c1.h" linenr="658" column="30" str="(" scope="0x7fd8ca69eed0" link="0x7fd8ca6a3af0" astOperand1="0x7fd8ca6a2e60" astOperand2="0x7fd8ca6a3880" valueType-type="void"/>
    <token id="0x7fd8ca6a3030" file="mcc_generated_files/i2c1.h" linenr="659" column="33" str="struct" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a4e30" file="mcc_generated_files/i2c1.h" linenr="659" column="0" str="I2C1_TRANSACTION_REQUEST_BLOCK" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca6a3130"/>
    <token id="0x7fd8ca6a3130" file="mcc_generated_files/i2c1.h" linenr="659" column="64" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca6a32d0" astOperand1="0x7fd8ca6a4e30" astOperand2="0x7fd8ca6a3200"/>
    <token id="0x7fd8ca6a3200" file="mcc_generated_files/i2c1.h" linenr="659" column="65" str="ptrb" scope="0x7fd8ca69eed0" type="name" varId="19" variable="0x7fd8ca6a5f50" astParent="0x7fd8ca6a3130" valueType-type="record" valueType-pointer="1"/>
    <token id="0x7fd8ca6a32d0" file="mcc_generated_files/i2c1.h" linenr="659" column="69" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a3610" astOperand1="0x7fd8ca6a3130" astOperand2="0x7fd8ca6a3470"/>
    <token id="0x7fd8ca6a33a0" file="mcc_generated_files/i2c1.h" linenr="660" column="33" str="uint8_t" scope="0x7fd8ca69eed0" type="name" astParent="0x7fd8ca6a3470"/>
    <token id="0x7fd8ca6a3470" file="mcc_generated_files/i2c1.h" linenr="660" column="41" str="*" scope="0x7fd8ca69eed0" type="op" isArithmeticalOp="True" astParent="0x7fd8ca6a32d0" astOperand1="0x7fd8ca6a33a0" astOperand2="0x7fd8ca6a3540"/>
    <token id="0x7fd8ca6a3540" file="mcc_generated_files/i2c1.h" linenr="660" column="42" str="pdata" scope="0x7fd8ca69eed0" type="name" varId="20" variable="0x7fd8ca6a6020" astParent="0x7fd8ca6a3470" valueType-type="char" valueType-sign="unsigned" valueType-pointer="1"/>
    <token id="0x7fd8ca6a3610" file="mcc_generated_files/i2c1.h" linenr="660" column="47" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a3880" astOperand1="0x7fd8ca6a32d0" astOperand2="0x7fd8ca6a37b0"/>
    <token id="0x7fd8ca6a36e0" file="mcc_generated_files/i2c1.h" linenr="661" column="33" str="uint8_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a37b0" file="mcc_generated_files/i2c1.h" linenr="661" column="41" str="length" scope="0x7fd8ca69eed0" type="name" varId="21" variable="0x7fd8ca6a60f0" astParent="0x7fd8ca6a3610" valueType-type="char" valueType-sign="unsigned"/>
    <token id="0x7fd8ca6a3880" file="mcc_generated_files/i2c1.h" linenr="661" column="47" str="," scope="0x7fd8ca69eed0" astParent="0x7fd8ca6a2f60" astOperand1="0x7fd8ca6a3610" astOperand2="0x7fd8ca6a3a20"/>
    <token id="0x7fd8ca6a3950" file="mcc_generated_files/i2c1.h" linenr="662" column="33" str="uint16_t" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a3a20" file="mcc_generated_files/i2c1.h" linenr="662" column="42" str="address" scope="0x7fd8ca69eed0" type="name" varId="22" variable="0x7fd8ca6a61c0" astParent="0x7fd8ca6a3880" valueType-type="short" valueType-sign="unsigned"/>
    <token id="0x7fd8ca6a3af0" file="mcc_generated_files/i2c1.h" linenr="662" column="49" str=")" scope="0x7fd8ca69eed0" link="0x7fd8ca6a2f60"/>
    <token id="0x7fd8ca6a3bc0" file="mcc_generated_files/i2c1.h" linenr="662" column="50" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca6a3c90" file="mcc_generated_files/i2c1.h" linenr="700" column="1" str="bool" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a3d60" file="mcc_generated_files/i2c1.h" linenr="700" column="6" str="I2C1_MasterQueueIsEmpty" scope="0x7fd8ca69eed0" type="name" function="0x7fd8ca6a5160" astParent="0x7fd8ca6a3e60"/>
    <token id="0x7fd8ca6a3e60" file="mcc_generated_files/i2c1.h" linenr="700" column="29" str="(" scope="0x7fd8ca69eed0" link="0x7fd8ca6a4000" astOperand1="0x7fd8ca6a3d60" valueType-type="bool"/>
    <token id="0x7fd8ca6a4000" file="mcc_generated_files/i2c1.h" linenr="700" column="34" str=")" scope="0x7fd8ca69eed0" link="0x7fd8ca6a3e60"/>
    <token id="0x7fd8ca6a40d0" file="mcc_generated_files/i2c1.h" linenr="700" column="35" str=";" scope="0x7fd8ca69eed0"/>
    <token id="0x7fd8ca6a41a0" file="mcc_generated_files/i2c1.h" linenr="738" column="1" str="bool" scope="0x7fd8ca69eed0" type="name"/>
    <token id="0x7fd8ca6a4270" file="mcc_generated_files/i2c1.h" linenr="738" column="6" str="I2C1_MasterQueueIsFull" scope="0x7fd8ca69eed0" type="name" function="0x7fd8ca6a5240" astParent="0x7fd8ca6a4340"/>
    <token id="0x7fd8ca6a4340" file="mcc_generated_files/i2c1.h" linenr="738" column="28" str="(" scope="0x7fd8ca69eed0" link="0x7fd8ca6a44e0" astOperand1="0x7fd8ca6a4270" valueType-type="bool"/>
    <token id="0x7fd8ca6a44e0" file="mcc_generated_files/i2c1.h" linenr="738" column="33" str=")" scope="0x7fd8ca69eed0" link="0x7fd8ca6a4340"/>
    <token id="0x7fd8ca6a45b0" file="mcc_generated_files/i2c1.h" linenr="738" column="34" str=";" scope="0x7fd8ca69eed0"/>
  </tokenlist>
  <scopes>
    <scope id="0x7fd8ca69eed0" type="Global">
      <functionList>
        <function id="0x7fd8ca69f290" tokenDef="0x7fd8ca69f0e0" name="I2C1_Initialize" type="Function"/>
        <function id="0x7fd8ca6a4b40" tokenDef="0x7fd8ca69f5c0" name="I2C1_MasterWrite" type="Function">
          <arg nr="1" variable="0x7fd8ca6a5320"/>
          <arg nr="2" variable="0x7fd8ca6a53f0"/>
          <arg nr="3" variable="0x7fd8ca6a54c0"/>
          <arg nr="4" variable="0x7fd8ca6a5590"/>
        </function>
        <function id="0x7fd8ca6a4be0" tokenDef="0x7fd8ca6a0460" name="I2C1_MasterRead" type="Function">
          <arg nr="1" variable="0x7fd8ca6a5660"/>
          <arg nr="2" variable="0x7fd8ca6a5730"/>
          <arg nr="3" variable="0x7fd8ca6a5800"/>
          <arg nr="4" variable="0x7fd8ca6a58d0"/>
        </function>
        <function id="0x7fd8ca6a4f40" tokenDef="0x7fd8ca6a1300" name="I2C1_MasterTRBInsert" type="Function">
          <arg nr="1" variable="0x7fd8ca6a59a0"/>
          <arg nr="2" variable="0x7fd8ca6a5a70"/>
          <arg nr="3" variable="0x7fd8ca6a5b40"/>
        </function>
        <function id="0x7fd8ca6a4fe0" tokenDef="0x7fd8ca6a1f60" name="I2C1_MasterReadTRBBuild" type="Function">
          <arg nr="1" variable="0x7fd8ca6a5c10"/>
          <arg nr="2" variable="0x7fd8ca6a5ce0"/>
          <arg nr="3" variable="0x7fd8ca6a5db0"/>
          <arg nr="4" variable="0x7fd8ca6a5e80"/>
        </function>
        <function id="0x7fd8ca6a5080" tokenDef="0x7fd8ca6a2e60" name="I2C1_MasterWriteTRBBuild" type="Function">
          <arg nr="1" variable="0x7fd8ca6a5f50"/>
          <arg nr="2" variable="0x7fd8ca6a6020"/>
          <arg nr="3" variable="0x7fd8ca6a60f0"/>
          <arg nr="4" variable="0x7fd8ca6a61c0"/>
        </function>
        <function id="0x7fd8ca6a5160" tokenDef="0x7fd8ca6a3d60" name="I2C1_MasterQueueIsEmpty" type="Function"/>
        <function id="0x7fd8ca6a5240" tokenDef="0x7fd8ca6a4270" name="I2C1_MasterQueueIsFull" type="Function"/>
      </functionList>
    </scope>
  </scopes>
  <variables>
    <var id="0x7fd8ca6a5320" nameToken="0x7fd8ca69f900" typeStartToken="0x7fd8ca69f760" typeEndToken="0x7fd8ca69f830" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a53f0" nameToken="0x7fd8ca69fb70" typeStartToken="0x7fd8ca69faa0" typeEndToken="0x7fd8ca69faa0" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="false" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a54c0" nameToken="0x7fd8ca69fde0" typeStartToken="0x7fd8ca69fd10" typeEndToken="0x7fd8ca69fd10" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="false" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5590" nameToken="0x7fd8ca6a0120" typeStartToken="0x7fd8ca69ff80" typeEndToken="0x7fd8ca6a0050" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5660" nameToken="0x7fd8ca6a07a0" typeStartToken="0x7fd8ca6a0600" typeEndToken="0x7fd8ca6a06d0" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5730" nameToken="0x7fd8ca6a0a10" typeStartToken="0x7fd8ca6a0940" typeEndToken="0x7fd8ca6a0940" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="false" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5800" nameToken="0x7fd8ca6a0c80" typeStartToken="0x7fd8ca6a0bb0" typeEndToken="0x7fd8ca6a0bb0" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="false" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a58d0" nameToken="0x7fd8ca6a0fc0" typeStartToken="0x7fd8ca6a0e20" typeEndToken="0x7fd8ca6a0ef0" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a59a0" nameToken="0x7fd8ca6a1570" typeStartToken="0x7fd8ca6a14a0" typeEndToken="0x7fd8ca6a14a0" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="false" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5a70" nameToken="0x7fd8ca6a18e0" typeStartToken="0x7fd8ca69e330" typeEndToken="0x7fd8ca6a1810" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5b40" nameToken="0x7fd8ca6a1c20" typeStartToken="0x7fd8ca6a1a80" typeEndToken="0x7fd8ca6a1b50" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5c10" nameToken="0x7fd8ca6a2300" typeStartToken="0x7fd8ca6a4d30" typeEndToken="0x7fd8ca6a2230" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5ce0" nameToken="0x7fd8ca6a2640" typeStartToken="0x7fd8ca6a24a0" typeEndToken="0x7fd8ca6a2570" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5db0" nameToken="0x7fd8ca6a28b0" typeStartToken="0x7fd8ca6a27e0" typeEndToken="0x7fd8ca6a27e0" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="false" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5e80" nameToken="0x7fd8ca6a2b20" typeStartToken="0x7fd8ca6a2a50" typeEndToken="0x7fd8ca6a2a50" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="false" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a5f50" nameToken="0x7fd8ca6a3200" typeStartToken="0x7fd8ca6a4e30" typeEndToken="0x7fd8ca6a3130" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a6020" nameToken="0x7fd8ca6a3540" typeStartToken="0x7fd8ca6a33a0" typeEndToken="0x7fd8ca6a3470" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="true" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a60f0" nameToken="0x7fd8ca6a37b0" typeStartToken="0x7fd8ca6a36e0" typeEndToken="0x7fd8ca6a36e0" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="false" isReference="false" isStatic="false"/>
    <var id="0x7fd8ca6a61c0" nameToken="0x7fd8ca6a3a20" typeStartToken="0x7fd8ca6a3950" typeEndToken="0x7fd8ca6a3950" access="Argument" scope="0x0" constness="0" isArgument="true" isArray="false" isClass="false" isConst="false" isExtern="false" isLocal="false" isPointer="false" isReference="false" isStatic="false"/>
  </variables>
  <valueflow>
  </valueflow>
</dump>
</dumps>
